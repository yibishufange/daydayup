# 事务的概念和特性
- 概念：事务（Transaction）是一个操作序列，不可分割的工作单位，以BEGIN TRANSACTION开始，以ROLLBACK/COMMIT结束；
- 特性(**ACID**)：
    - **原子性(Atomicity)**：逻辑上是不可分割的操作单元，事务的所有操作要么全部提交成功，要么全部失败回滚（用回滚日志实现，反向执行日志中的操作）；
    - **一致性(Consistency)**：事务的执行必须使数据库保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的；
    - **隔离性(Isolation)**：一个事务所做的修改在最终提交以前，对其它事务是不可见的（并发执行的事务之间不能相互影响）；
    - **持久性(Durability)**：一旦事务提交成功，对数据的修改是永久性的；
----
# 并发一致性问题
- **丢失修改**：一个事务对数据进行了修改，在事务提交之前，另一个事务对同一个数据进行了修改，覆盖了之前的修改；
- **脏读**：一个事务读取了被另一个事务修改、但未提交（进行了回滚）的数据，造成两个事务得到的数据不一致；
- **不可重复读**：在同一个事务中，某查询操作在一个时间读取某一行数据和之后一个时间读取该行数据，发现数据已经发生修改（可能被更新或删除了）；
- **幻读**：当同一查询多次执行时，由于其它事务在这个数据范围内执行了插入操作，会导致每次返回不同的结果集（和不可重复读的区别：针对的是一个数据整体/范围；并且需要是插入操作）
----
# 数据库的四种隔离级别
- **未提交读**：在一个事务提交之前，它的执行结果对其它事务也是可见的。会导致脏读、不可重复读、幻读；
- **提交读**：一个事务只能看见已经提交的事务所作的改变。可避免脏读问题；
- **可重复读**：可以确保同一个事务在多次读取同样的数据时得到相同的结果。**（MySQL的默认隔离级别）**。可避免不可重复读；
- **可串行化**：强制事务串行执行，使之不可能相互冲突，从而解决幻读问题。可能导致大量的超时现象和锁竞争，实际很少使用。
----
# 乐观锁和悲观锁
- **悲观锁**：认为数据随时会被修改，因此每次读取数据之前都会上锁，防止其它事务读取或修改数据；**应用于数据更新比较频繁的场景；**
- **乐观锁**：操作数据时不会上锁，但是更新时会判断在此期间有没有别的事务更新这个数据，若被更新过，则失败重试；**适用于读多写少的场景。**
- 乐观锁的实现方式：
    - 加一个版本号或者时间戳字段，每次数据更新时同时更新这个字段；
    - 先读取想要更新的字段或者所有字段，更新的时候比较一下，只有字段没有变化才进行更新；
----
# 常见的封锁类型
- **排它锁/X锁**：事务对数据加上X锁时，只允许此事务读取和修改此数据，并且其它事务不能对该数据加任何锁；
- **共享锁/S锁**：加了S锁后，该事务只能对数据进行读取而不能修改，并且其它事务只能加S锁，不能加X锁；
- **意向锁**：
  - 一个事务在获得某个数据行对象的 S 锁之前，必须先获得整个表的 IS 锁或更强的锁；
  - 一个事务在获得某个数据行对象的 X 锁之前，必须先获得整个表的 IX 锁；
  - IS/IX 锁之间都是兼容的；
  - 好处：如果一个事务想要对整个表加X锁，就需要先检测是否有其它事务对该表或者该表中的某一行加了锁，这种检测非常耗时。有了意向锁之后，只需要检测整个表是否存在IX/IS/X/S锁就行了；
- 锁的作用：用于管理对共享资源的并发访问，保证数据库的完整性和一致性；
- 封锁粒度：MySQL 中提供了两种封锁粒度：**行级锁**以及**表级锁。**
  - 封锁粒度小：
    - 好处：锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高；
    - 坏处：系统开销大（加锁、释放锁、检查锁的状态都需要消耗资源）
- MySql加锁：
```
SELECT ... LOCK In SHARE MODE;
SELECT ... FOR UPDATE;
```
----
# 三级封锁协议
- **一级封锁协议**：事务在修改数据之前必须先对其加X锁，直到事务结束才释放。**可以解决丢失修改问题**（两个事务不能同时对一个数据加X锁，避免了修改被覆盖）；
- **二级封锁协议**：在一级的基础上，事务在读取数据之前必须先加S锁，读完后释放。**可以解决脏读问题**（如果已经有事务在修改数据，就意味着已经加了X锁，此时想要读取数据的事务并不能加S锁，也就无法进行读取，避免了读取脏数据）；
- **三级封锁协议**：在二级的基础上，事务在读取数据之前必须先加S锁，直到事务结束才能释放。**可以解决不可重复读问题**（避免了在事务结束前其它事务对数据加X锁进行修改，保证了事务期间数据不会被其它事务更新）
----
# 两段锁协议
事务必须严格分为两个阶段对数据进行**加锁**和**解锁**的操作，第一阶段加锁，第二阶段解锁。**也就是说一个事务中一旦释放了锁，就不能再申请新锁了。**

可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。**事务遵循两段锁协议是保证可串行化调度的充分条件。**

