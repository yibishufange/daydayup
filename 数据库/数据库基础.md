   * [事务的概念和特性](#事务的概念和特性)
   * [并发一致性问题](#并发一致性问题)
   * [数据库的四种隔离级别](#数据库的四种隔离级别)
   * [乐观锁和悲观锁](#乐观锁和悲观锁)
   * [常见的封锁类型](#常见的封锁类型)
   * [三级封锁协议](#三级封锁协议)
   * [两段锁协议](#两段锁协议)
   * [MVCC](#mvcc)
   * [数据库的范式](#数据库的范式)
   * [表的连接方式](#表的连接方式)
   * [存储过程](#存储过程)
   * [delete/drop/truncate区别](#deletedroptruncate区别)
   * [视图 /游标](#视图-游标)

# 事务的概念和特性
- 概念：事务（Transaction）是一个操作序列，不可分割的工作单位，以BEGIN TRANSACTION开始，以ROLLBACK/COMMIT结束；
- 特性(**ACID**)：
    - **原子性(Atomicity)**：逻辑上是不可分割的操作单元，事务的所有操作要么全部提交成功，要么全部失败回滚（用回滚日志实现，反向执行日志中的操作）；
    - **一致性(Consistency)**：事务的执行必须使数据库保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的；
    - **隔离性(Isolation)**：一个事务所做的修改在最终提交以前，对其它事务是不可见的（并发执行的事务之间不能相互影响）；
    - **持久性(Durability)**：一旦事务提交成功，对数据的修改是永久性的；
----
# 并发一致性问题
- **丢失修改**：一个事务对数据进行了修改，在事务提交之前，另一个事务对同一个数据进行了修改，覆盖了之前的修改；
- **脏读**：一个事务读取了被另一个事务修改、但未提交（进行了回滚）的数据，造成两个事务得到的数据不一致；
- **不可重复读**：在同一个事务中，某查询操作在一个时间读取某一行数据和之后一个时间读取该行数据，发现数据已经发生修改（可能被更新或删除了）；
- **幻读**：当同一查询多次执行时，由于其它事务在这个数据范围内执行了插入操作，会导致每次返回不同的结果集（和不可重复读的区别：针对的是一个数据整体/范围；并且需要是插入操作）
----
# 数据库的四种隔离级别
- **未提交读**：在一个事务提交之前，它的执行结果对其它事务也是可见的。会导致脏读、不可重复读、幻读；
- **提交读**：一个事务只能看见已经提交的事务所作的改变。可避免脏读问题；
- **可重复读**：可以确保同一个事务在多次读取同样的数据时得到相同的结果。**（MySQL的默认隔离级别）**。可避免不可重复读；
- **可串行化**：强制事务串行执行，使之不可能相互冲突，从而解决幻读问题。可能导致大量的超时现象和锁竞争，实际很少使用。
----
# 乐观锁和悲观锁
- **悲观锁**：认为数据随时会被修改，因此每次读取数据之前都会上锁，防止其它事务读取或修改数据；**应用于数据更新比较频繁的场景；**
- **乐观锁**：操作数据时不会上锁，但是更新时会判断在此期间有没有别的事务更新这个数据，若被更新过，则失败重试；**适用于读多写少的场景。**
- 乐观锁的实现方式：
    - 加一个版本号或者时间戳字段，每次数据更新时同时更新这个字段；
    - 先读取想要更新的字段或者所有字段，更新的时候比较一下，只有字段没有变化才进行更新；
----
# 常见的封锁类型
- **排它锁/X锁**：事务对数据加上X锁时，只允许此事务读取和修改此数据，并且其它事务不能对该数据加任何锁；
- **共享锁/S锁**：加了S锁后，该事务只能对数据进行读取而不能修改，并且其它事务只能加S锁，不能加X锁；
- **意向锁**：
  - 一个事务在获得某个数据行对象的 S 锁之前，必须先获得整个表的 IS 锁或更强的锁；
  - 一个事务在获得某个数据行对象的 X 锁之前，必须先获得整个表的 IX 锁；
  - IS/IX 锁之间都是兼容的；
  - 好处：如果一个事务想要对整个表加X锁，就需要先检测是否有其它事务对该表或者该表中的某一行加了锁，这种检测非常耗时。有了意向锁之后，只需要检测整个表是否存在IX/IS/X/S锁就行了；
- 锁的作用：用于管理对共享资源的并发访问，保证数据库的完整性和一致性；
- 封锁粒度：MySQL 中提供了两种封锁粒度：**行级锁**以及**表级锁。**
  - 封锁粒度小：
    - 好处：锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高；
    - 坏处：系统开销大（加锁、释放锁、检查锁的状态都需要消耗资源）
- MySql加锁：
```
SELECT ... LOCK In SHARE MODE;
SELECT ... FOR UPDATE;
```
----
# 三级封锁协议
- **一级封锁协议**：事务在修改数据之前必须先对其加X锁，直到事务结束才释放。**可以解决丢失修改问题**（两个事务不能同时对一个数据加X锁，避免了修改被覆盖）；
- **二级封锁协议**：在一级的基础上，事务在读取数据之前必须先加S锁，读完后释放。**可以解决脏读问题**（如果已经有事务在修改数据，就意味着已经加了X锁，此时想要读取数据的事务并不能加S锁，也就无法进行读取，避免了读取脏数据）；
- **三级封锁协议**：在二级的基础上，事务在读取数据之前必须先加S锁，直到事务结束才能释放。**可以解决不可重复读问题**（避免了在事务结束前其它事务对数据加X锁进行修改，保证了事务期间数据不会被其它事务更新）

----
# 两段锁协议
事务必须严格分为两个阶段对数据进行**加锁**和**解锁**的操作，第一阶段加锁，第二阶段解锁。**也就是说一个事务中一旦释放了锁，就不能再申请新锁了。**

可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。**事务遵循两段锁协议是保证可串行化调度的充分条件。**

----
# MVCC

多版本并发控制，MVCC在每行记录后面都保存有两个隐藏的列，用来存储**创建版本号**和**删除版本号**。

通过版本号减少了锁的争用，提高了系统性能；可以实现**提交读**和**可重复读**两种隔离级别，未提交读无需使用MVCC；

----

# 数据库的范式

- 第一范式：属性不应该是可分的；
- 第二范式：每个非主属性完全依赖于主属性集；
- 第三范式：在2NF的基础上，非主属性不传递依赖于主属性；

----

# 表的连接方式

- 内连接（Inner Join)：仅将两个表中满足连接条件的行组合起来作为结果集

- 外连接（Outer Join）：

  - 左连接（Left Join）：左边表的所有数据都显示出来，右边的表数据只显示共有部分，没有对应的部分补NULL；

  - 右连接（Right Join）：与左连接相反；

  - 全外连接（Full Outer Join）：查询出左表和右表所有数据，但是去除两表的重复数据；

- 交叉连接(Cross Join)：返回两表的笛卡尔积（m*n）; 

----
# 存储过程

存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合。想要实现相应的功能时，只需要调用这个存储过程就行了（类似于函数，输入具有输出参数）；

优点：

- 预先编译，而不需要每次运行时编译，提高了数据库执行**效率**；

- 封装了一系列操作，对于一些数据交互比较多的操作，相比于单独执行SQL语句，可以**减少网络通信量**；

- 具有**可复用性**，减少了数据库开发的工作量；

- **安全性高**，可以让没有权限的用户通过存储过程间接操作数据库；

- 更**易于维护**

缺点：

- **可移植性差**，存储过程将应用程序绑定到了数据库上；
- **开发调试复杂**：没有好的IDE；
- **修改复杂**，需要重新编译，有时还需要更新程序中的代码以更新调用；



----

# delete/drop/truncate区别

- **Delete**用来删除表的全部或者**部分数据**，执行delete之后，用户**需要提交**之后才会执行，会触发表上的DELETE**触发器**（包含一个OLD的虚拟表，可以只读访问被删除的数据），DELETE之后表结构还在，删除很慢，一行一行地删，因为会记录日志，可以利用日志还原数据；
- **Truncate**删除表中的所有数据，这个操作**不能回滚**，也不会触发这个表上的触发器。操作比DELETE快很多（直接把表drop掉，再创建一个新表，删除的数据不能找回）。如果表中有自增（AUTO_INCREMENT）列，则重置为1；
- **Drop**命令从数据库中**删除表**，所有的数据行，索引和约束都会被删除；不能回滚，不会触发触发器；

----

# 视图 /游标

- 视图：从数据库的基本表中通过查询选取出来的数据组成的虚拟表（数据库中存放视图的定义）。可以对其进行增/删/改/查等操作。特别地，对视图的修改不影响基本表。好处：
  - 通过只给用户访问视图的权限，保证数据的**安全性**；
  - **简化**复杂的SQL操作，隐藏数据的复杂性（比如复杂的连接）；
- 游标（Cursor）：用于定位在查询返回的**结果集的特定行**，以对特定行进行操作。使用游标可以方便地对结果集进行移动遍历，根据需要滚动或对浏览/修改任意行中的数据。主要用于交互式应用。
