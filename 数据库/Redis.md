
   * [Redis](#redis)
   * [数据类型](#数据类型)
   * [Redis与Memcached](#redis与memcached)
   * [键的过期时间](#键的过期时间)
   * [内存数据淘汰策略](#内存数据淘汰策略)
   * [持久化](#持久化)
   * [事务](#事务)
   * [事件](#事件)
   * [主从复制](#主从复制)
   * [哨兵Sentinel](#哨兵sentinel)
   * [分片](#分片)
   * [简单论坛系统的分析](#简单论坛系统的分析)

# 一、简介

Redis 是速度非常快的非关系型（NoSQL）**内存键值数据库**，可以存储键和五种不同类型的值之间的映射。

键的类型只能为字符串，值支持五种数据类型：**字符串、列表、集合、散列表、有序集合**。

Redis 支持很多特性，例如将内存中的**数据持久化**到硬盘中，使用**复制**来扩展读性能，使用**分片**来扩展写性能。

---

# 二、数据类型

- **STRING** 
  - 可以存储字符串、整数、浮点数；
  - 操作：对字符串或者字符串的其中一部分执行操作；对整数和浮点数执行自增或者自减操作；
  - 应用：常规计数：微博数，粉丝数等；
- **LIST 列表**
  - 操作：两端压入或者弹出元素；对单个或者多个元素进行修剪；只保留一个范围内的元素；
  - 应用：微博关注列表、粉丝列表、消息列表等；
- **HASH 散列表**
  - 操作：添加、获取、移除键值对；获取所有键值对；检查某个键是否存在；
  - 应用：存储用户信息、商品信息等；
- **SET 无序集合**
  - 操作：添加、获取、移除单个元素；检查一个元素是否存在集合中；计算交集、并集、差集；从集合中随机获取元素；
  - 应用：共同关注、共同粉丝、共同喜好；
- **ZSET 有序集合**
  - 操作：添加、获取、删除元素；根据分值范围或者成员来获取元素；计算一个键的排名；
  - 应用：排行信息；排行榜；
  - 底层实现：跳跃表；

---

# 三、底层数据结构

## 1、简单动态字符串SDS

- string类型的底层实现；
- 定义：

```c
// 保存字符串对象的结构   
struct sdshdr {  
    // buf 中已占用空间的长度  
    int len;  
    // buf 中剩余可用空间的长度  
    int free;  
    // 数据空间  
    char buf[];  
};
```

- 与C字符串的区别：

  | C 字符串                                   | SDS                                    |
  | ------------------------------------------ | -------------------------------------- |
  | 获取字符串长度的复杂度为O（N)              | 获取字符串长度的复杂度为O(1)           |
  | API 是不安全的，可能会造成缓冲区溢出       | API 是安全的，不会造成缓冲区溢出       |
  | 修改字符串长度N次必然需要执行N次内存重分配 | 修改字符串长度N次最多执行N次内存重分配 |
  | 只能保存文本数据                           | 可以保存二进制数据和文本文数据         |
  | 可以使用所有<String.h>库中的函数           | 可以使用一部分<string.h>库中的函数     |

## 2、链表

　　链表提供了高效的节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活地调整链表的长度。

　　链表在Redis 中的应用非常广泛，比如**列表键的底层实现之一就是链表**。当一个列表键包含了数量较多的元素，又或者列表中包含的元素都是比较长的字符串时，Redis 就会使用链表作为列表键的底层实现。

- 特性：
  - 双端：链表节点带有prev 和next 指针，获取某个节点的前置节点和后置节点的时间复杂度都是O（N）
  - 无环：表头节点的 prev 指针和表尾节点的next 都指向NULL，对立案表的访问时以NULL为截止
  - 表头和表尾：因为链表带有head指针和tail 指针，程序获取链表头结点和尾节点的时间复杂度为O(1)
  - 长度计数器：链表中存有记录链表长度的属性 len
  - 多态：链表节点使用 void\* 指针来保存节点值，并且可以通过list 结构的dup 、 free、 match三个属性为节点值设置类型特定函数。

## 3、字典

字典，又称为符号表（symbol table）、关联数组（associative array）或映射（map），是一种用于保存键值对的抽象数据结构。

- 定义

  ```c
  typedef struct dictEntry{
     //键
     void *key;
     //值
     union{
        void *val;
        uint64_tu64;
        int64_ts64;
     }   struct dictEntry *next;
  };
  
  typedef struct dictht {
     //哈希表数组
     dictEntry **table;
     //哈希表大小
     unsigned long size;
     //哈希表大小掩码，用于计算索引值
     unsigned long sizemask;
     //该哈希表已有节点的数量
     unsigned long used;
  };
  
  typedef struct dict {    // 类型特定函数
      dictType *type;    // 私有数据
      void *privedata;    // 哈希表
      dictht  ht[2];
      // rehash 索引
      in trehashidx;
  };
  ```

- 哈希冲突解决：**链地址法**

- **Rehash**

  随着对哈希表的不断操作，哈希表保存的键值对会逐渐的发生改变，为了让哈希表的负载因子维持在一个合理的范围之内，我们需要对哈希表的大小进行相应的扩展或者压缩，这时候，我们可以通过 rehash（重新散列）操作来完成。

  - **目前的哈希表状态：**

    我们可以看到，哈希表中的每个节点都已经使用到了，这时候我们需要对哈希表进行拓展。

    ![](https://images2015.cnblogs.com/blog/1053081/201701/1053081-20170102213822316-795162750.png)

  - **为哈希表分配空间**：

    哈希表空间分配规则：

    如果执行的是拓展操作，那么ht[1] 的大小为第一个大于等于ht[0] 的2的n次幂

    如果执行的是收缩操作，那么ht[1] 的大小为第一个小于等于ht[0] 的2的n次幂

    因此这里我们为ht[1] 分配 空间为8，

    ![](https://images2015.cnblogs.com/blog/1053081/201701/1053081-20170102213924144-1854942861.png)

  - **数据转移：**

    将ht[0]中的数据转移到ht[1]中，在转移的过程中，需要对哈希表节点的数据重新进行哈希值计算，

    ![](https://images2015.cnblogs.com/blog/1053081/201701/1053081-20170102214334769-1157973551.png)

  - **释放ht[0]:**

    将ht[0]释放，然后将ht[1]设置成ht[0]，最后为ht[1]分配一个空白哈希表：

    ![](https://images2015.cnblogs.com/blog/1053081/201701/1053081-20170102214455034-353712227.png)

  - **渐进式 rehash**：

    上面我们说到，在进行拓展或者压缩的时候，可以直接将所有的键值对rehash 到ht[1]中，这是因为数据量比较小。在实际开发过程中，这个rehash 操作并不是一次性、集中式完成的，而是分多次、渐进式地完成的。

    渐进式rehash 的详细步骤：

    1、为ht[1] 分配空间，让字典同时持有ht[0]和ht[1]两个哈希表

    2、在几点钟维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash 开始

    3、在rehash 进行期间，每次对字典执行CRUD操作时，程序除了执行指定的操作以外，还会将ht[0]中的数据rehash 到ht[1]表中，并且将rehashidx加一

    4、当ht[0]中所有数据转移到ht[1]中时，将rehashidx 设置成-1，表示rehash 结束

    采用渐进式rehash 的好处在于它采取分而治之的方式，避免了集中式rehash 带来的庞大计算量。

## 4、跳跃表

**跳跃表（skiplist）**是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。跳跃表是一种随机化的数据,跳跃表以有序的方式在层次化的链表中保存元素，效率和平衡树媲美 ——查找、删除、添加等操作都可以在对数期望时间下完成，并且比起平衡树来说，跳跃表的实现要简单直观得多。

- 跳跃表是**有序集合**的底层实现之一
-   主要有zskiplist 和zskiplistNode两个结构组成
-   每个跳跃表节点的层高都是1至32之间的随机数
-   在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的对象必须是唯一的
-   节点按照分值的大小从大到小排序，如果分值相同，则按成员对象大小排序

## 5、整数集合

整数集合，他其实就是一个特殊的集合，里面存储的数据只能够是整数，并且数据量不能过大。

- 实现：

  ```c
  typedef struct intset{
      //编码方式
      uint32_t enconding;
     // 集合包含的元素数量
      uint32_t length;
      //保存元素的数组    
      int8_t contents[];
  };
  ```
  
- 总结：

  - **整数集合是集合建的底层实现之一；**

  - 整数集合的底层实现为数组，这个数组以有序，无重复的范式保存集合元素，在有需要时，程序会根据新添加的元素类型改变这个数组的类型；

  - 升级操作为整数集合带来了操作上的灵活性，并且尽可能地节约了内存；

  - 整数集合只支持升级操作，不支持降级操作；

## 6、压缩列表

**压缩列表是列表键和哈希键的底层实现之一。**当一个列表键只包含少量列表项，并且每个列表项要么就是小整数，要么就是长度比较短的字符串，那么Redis 就会使用压缩列表来做列表键的底层实现。

- 压缩列表是一种为了节约内存而开发的顺序型数据结构

- 压缩列表被用作列表键和哈希键的底层实现之一

- 压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值

- 添加新节点到压缩列表，可能会引发连锁更新操作。

---

# 四、Redis与Memcached

两者都是非关系型内存键值数据库，主要有以下不同：

- **数据类型**

  Memcached 仅支持字符串类型，而 Redis 支持五种不同的数据类型，可以更灵活地解决问题。

- **数据持久化**

  Redis 支持两种持久化策略：RDB 快照和 AOF 日志，而 Memcached 不支持持久化。

- **分布式**

  Memcached 不支持分布式，只能通过在客户端使用一致性哈希来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。

  Redis Cluster 实现了分布式的支持。

- **内存管理机制**

  - 在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘，而 Memcached 的数据则会一直在内存中。
  - Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。

---

# 五、键的过期时间

Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。

对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间。

- 定期删除

  redis默认是每隔 100ms 就**随机抽取**一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！

- 惰性删除

  定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。这就是所谓的惰性删除，也是够懒的哈！

  

# 六、内存数据淘汰策略

  可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。

  Redis 具体有 6 种淘汰策略：

| 策略            |                         描述                         |
| --------------- | :--------------------------------------------------: |
| volatile-lru    | 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰 |
| volatile-ttl    |   从已设置过期时间的数据集中挑选将要过期的数据淘汰   |
| volatile-random |      从已设置过期时间的数据集中任意选择数据淘汰      |
| allkeys-lru     |       从所有数据集中挑选最近最少使用的数据淘汰       |
| allkeys-random  |          从所有数据集中任意选择数据进行淘汰          |
| noeviction      |                     禁止驱逐数据                     |

  使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。

  Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。

---

# 七、持久化

  Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。

  - **RDB持久化（默认）**

    将某个时间点的所有数据都存放到硬盘上。

    可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。

    如果系统发生故障，将会丢失最后一次创建快照之后的数据。

    如果数据量很大，保存快照的时间会很长。

  - **AOF持久化**

    将写命令添加到 AOF 文件（Append Only File）的末尾。

    使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项：

    | 选项     | 同步频率                 |
    | -------- | ------------------------ |
    | always   | 每个写命令都同步         |
    | everysec | 每秒同步一次             |
    | no       | 让操作系统来决定何时同步 |

    - always 选项会严重减低服务器的性能；
    - everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；
    - no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量。

    随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。

---

# 八、事务

一个事务包含了多个命令，服务器在执行事务期间，不会改去执行其它客户端的命令请求。

事务中的多个命令被一次性发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。

Redis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来。

---

# 九、事件

Redis 服务器是一个事件驱动程序。

- **文件事件**

  服务器通过套接字与客户端或者其它服务器进行通信，文件事件就是对套接字操作的抽象。

  Redis 基于 Reactor 模式开发了自己的网络事件处理器，使用 I/O 多路复用程序来同时监听多个套接字，并将到达的事件传送给文件事件分派器，分派器会根据套接字产生的事件类型调用相应的事件处理器。

- **时间事件**

  服务器有一些操作需要在给定的时间点执行，时间事件是对这类定时操作的抽象。

  时间事件又分为：

  - 定时事件：是让一段程序在指定的时间之内执行一次；
  - 周期性事件：是让一段程序每隔指定时间就执行一次。

  **Redis 将所有时间事件都放在一个无序链表中，通过遍历整个链表查找出已到达的时间事件，并调用相应的事件处理器。**

---

# 十、主从复制

通过使用 **slaveof host port** 命令来让一个服务器成为另一个服务器的从服务器。

一个从服务器只能有一个主服务器，并且不支持主主复制。

## 作用：

- **数据冗余**：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。
- **故障恢复**：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。
- **负载均衡**：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。
- **高可用基石**：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。

## 实现原理：

### 1、连接建立阶段

该阶段的主要作用是在主从节点之间建立连接，为数据同步做好准备。

- 保存主节点信息
- 建立socket连接
- 发送ping命令
- 身份验证
- 发送从节点端口信息

### 2、数据同步阶段

主从节点之间的连接建立以后，便可以开始进行数据同步，该阶段可以理解为从节点数据的初始化。具体执行的方式是：从节点向主节点发送psync命令（Redis2.8以前是sync命令），开始同步。

数据同步阶段是主从复制最核心的阶段，根据主从节点当前状态的不同，可以分为**全量复制和部分复制**，下面会有一章专门讲解这两种复制方式以及psync命令的执行过程，这里不再详述。

- **全量复制**

  用于初次复制或其他无法进行部分复制的情况，将主节点中的所有数据都发送给从节点，是一个非常重型的操作。

- **部分复制**

  用于网络中断等情况后的复制，只将中断期间主节点执行的写命令发送给从节点，与全量复制相比更加高效。需要注意的是，如果网络中断时间过长，导致主节点没有能够完整地保存中断期间执行的写命令，则无法进行部分复制，仍使用全量复制。

### 3、命令传播阶段

数据同步阶段完成后，主从节点进入命令传播阶段；在这个阶段主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保证主从节点数据的一致性。

在命令传播阶段，除了发送写命令，主从节点还维持着**心跳机制**：PING和REPLCONF ACK。

- **主->从：PING**

  每隔指定的时间，**主节点会向从节点发送**PING命令，这个PING命令的作用，主要是为了让从节点进行超时判断。PING发送的频率由repl-ping-slave-period参数控制，单位是秒，默认值是10s。

- **从->主：REPLCONF ACK**

  在命令传播阶段，**从节点会向主节点发送**REPLCONF ACK命令，频率是每秒1次；命令格式为：REPLCONF ACK {offset}，其中offset指从节点保存的复制偏移量。

  REPLCONF ACK命令的作用包括：

  - 实时监测主从节点网络状态；

  - 检测命令丢失；

  - 辅助保证从节点的数量和延迟；

## 单机内存大小限制

- **切主**：当主节点宕机时，一种常见的容灾策略是将其中一个从节点提升为主节点，并将其他从节点挂载到新的主节点上，此时这些从节点只能进行全量复制；如果Redis单机内存达到10GB，一个从节点的同步时间在几分钟的级别；如果从节点较多，恢复的速度会更慢。如果系统的读负载很高，而这段时间从节点无法提供服务，会对系统造成很大的压力。

- **从库扩容**：如果访问量突然增大，此时希望增加从节点分担读负载，如果数据量过大，从节点同步太慢，难以及时应对访问量的暴增。

- **缓冲区溢出**：（1）和（2）都是从节点可以正常同步的情形（虽然慢），但是如果数据量过大，导致全量复制阶段主节点的复制缓冲区溢出，从而导致复制中断，则主从节点的数据同步会全量复制->复制缓冲区溢出导致复制中断->重连->全量复制->复制缓冲区溢出导致复制中断……的循环。

- **超时**：如果数据量过大，全量复制阶段主节点fork+保存RDB文件耗时过大，从节点长时间接收不到数据触发超时，主从节点的数据同步同样可能陷入全量复制->超时导致复制中断->重连->全量复制->超时导致复制中断……的循环。

  此外，主节点单机内存除了绝对量不能太大，其占用主机内存的比例也不应过大：最好只使用50%-65%的内存，留下30%-45%的内存用于执行bgsave命令和创建复制缓冲区等。

## 常见问题：

### 复制中断

- **复制超时**：

  - 超时判断：

    在复制连接建立过程中及之后，主从节点都有机制判断连接是否超时，其意义在于：

    （1）如果主节点判断连接超时，其会释放相应从节点的连接，从而释放各种资源，否则无效的从节点仍会占用主节点的各种资源（输出缓冲区、带宽、连接等）；此外连接超时的判断可以让主节点更准确的知道当前有效从节点的个数，有助于保证数据安全（配合前面讲到的min-slaves-to-write等参数）。

    （2）如果从节点判断连接超时，则可以及时重新建立连接，避免与主节点数据长期的不一致。

- **复制缓冲区溢出**：

  ​		在全量复制阶段，主节点会将执行的写命令放到复制缓冲区中，该缓冲区存放的数据包括了以下几个时间段内主节点执行的写命令：bgsave生成RDB文件、RDB文件由主节点发往从节点、从节点清空老数据并载入RDB文件中的数据。当主节点数据量较大，或者主从节点之间网络延迟较大时，可能导致该缓冲区的大小超过了限制，此时主节点会断开与从节点之间的连接；这种情况可能引起全量复制->复制缓冲区溢出导致连接中断->重连->全量复制->复制缓冲区溢出导致连接中断……的循环。

---

# 十一、哨兵Sentinel

Sentinel（哨兵）可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。

----

# 十二、分片

分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得线性级别的性能提升。

- 范围分片
- 哈希分片

----

# 十三、简单论坛系统的分析

功能如下：

- 可以发布文章；（文章信息通过**HASH**来存储）
- 可以对文章进行点赞；（用**SET**实现点赞用户集合）
- 在首页可以按文章的发布时间或者文章的点赞数进行排序显示。（用**ZSET**实现按照点赞数排序等）
