  \* [HTTP协议简介](#http协议简介)

  \* [HTTP报文](#http报文)

  \* [HTTP状态码](#http状态码)

  \* [Web服务器](#web服务器)

  \* [HTTP报文首部](#http报文首部)

  \* [HTTPS](#https)

# HTTP协议简介

- HTTP协议用于客户端和服务器端之间的通信；
- 通过请求和响应的交换完成通信；
- **HTTP是不保存状态的协议；为了实现保存状态的功能，引入了Cookie技术；**
- 请求URI(*统一资源标志符*)定位资源；
- 告知服务器意图的HTTP方法:
    + **GET**：获取资源，当前网络请求中，绝大部分使用的是 GET 方法。
    + **POST**：传输实体主体，POST 主要用来传输数据，而 GET 主要用来获取资源。
    + PUT：传输文件。由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。
    + **HEAD**：获取报文首部，和 GET 方法类似，但是不返回报文实体主体部分。主要用于确认 URL 的有效性以及资源更新的日期时间等。
    + DELETE：删除文件
    + **OPTIONS**：询问支持的方法
    + TRACE：追踪路径
    + **CONNECT**：要求用隧道协议连接代理
- 使用**方法**下达命令；
- **持久连接节省通信量；**
    + 只要任意一端没有明确提出断开连接，则保持TCP连接状态
    + 好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载
    + HTTP/1.1中，所有连接默认为持久连接
    + 管线化，pipelining，同时并行发送多个请求；
- **使用Cookie管理状态；**
    + 服务器端发送的响应报文中增加Set-Cookie首部字段信息，通知客户端保存Cookie
    + 下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去
    + 服务器根据请求中的Cookie信息，进行状态管理；
---

# Cookie与Session

- Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；
- Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；
- 对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。

----
# HTTP报文
- 请求报文/响应报文
- 报文首部+报文主体；由回车+换行分隔；不一定有报文主体；
- 报文首部： 请求行/状态行 + 首部字段(请求首部字段/响应首部字段 + 通用首部字段 + 实体首部字段 + 其他)
- **内容编码提升传输速率**
    + 压缩传输的内容编码：常用**gzip/compress/deflate/identify**
    + 分割发送的**分块传输编码**：传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面
- 发送多种数据的多部分对象集合：Content-type
- 获取部分内容的**范围请求**
    + 针对范围请求**Range** 首部字段，响应会返回状态码为206 Partial Content的响应报文
    + 如果服务器无法响应范围请求，会返回状态码200 OK和完整的实体内容
- **内容协商**返回最合适的内容
----
# HTTP状态码
- 状态码告知从服务器返回的请求结果； 三位数字 + 原因短语构成；
- 状态码的类别：

状态码|类别|原因短语
--|--|--
1XX|Informational(信息性状态码)|接受的请求正在梳理
2XX|Succcess(成功状态码)|请求正常处理完毕
3XX|Redirection(重定向状态码)|需要进行附加操作以完成请求
4XX|Client Error(客户端错误状态码)|服务器无法处理请求
5XX|Server Error(服务器错误状态码)|服务器处理请求出错

- 2XX 成功：
    + **200 OK**：表示从客户端发来的请求在服务器端被正常处理了
    + **204 No Content**：服务器接收的请求已成功处理，但是返回的响应报文不含实体的主体部分
    + **206 Partial Content**：客户端进行了范围请求，服务器端成功执行了请求
- 3XX 重定向：
    + **301 Moved Permanently**：永久性重定向
    + **302 Found**：临时性重定向
    + **303 See Other**：请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源
    + **304 Not Modified**：客户端发送附带条件的请求时，服务器端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回304
    + **307 Temporary Redirect**：临时重定向
- 4XX 客户端错误
    + **400 Bad Request**: 请求报文存在语法错误
    + **401 Unauthorized**: 表示请求需要通过HTTP认证，若之前已进行一次请求，则表示认证失败
    + **403 Forbidden**: 表示对请求资源的访问被服务器拒绝了
    + **404 Not Found**：表示服务器上无法找到请求的资源
- 5XX 服务器错误
    + **500 Internal Server Error**：服务器在执行请求时发生错误
    + **503 Service Unavailable**：表示服务器暂时处于超负载或正在进行停机维护，现在无法处理请求
----
# Web服务器
- 用单台**虚拟主机**实现多个域名
    + 发送HTTP请求时，必须在HOST首部内完整指定主机名和域名的URI
- 通信数据转发程序：代码、网关、隧道
    + **代理**：
        + 代理不改变请求URI
        + 代理可级联，每次通过代码服务器转发请求时，会追加写入Via首部信息
        + 通过设置组织内部的代理服务器可做到针对特定URI的访问控制
        + 利用缓存技术减少网络带宽的流量
        + 缓存代理、透明代理
    + **网关**：
        + 通过网关可以由HTTP请求转化为其他协议的通信
    + **隧道**：
        + 确保客户端与服务器进行安全通信
- 保存资源的缓存
    + 缓存是指代理服务器与客户端本地保存的资源副本
    + 利用缓存可减少对源服务器的访问，因此可节省通信流量和通信时间
    + 缓存服务器是代理服务器的一种，归类在缓存代理类型中
    + 缓存的有效期限
    + 客户端的缓存
----
# HTTP报文首部
- 通用首部字段
- 请求首部字段
- 响应首部字段
- 实体首部字段
----
# HTTPS
- HTTP的缺点：
    + **通信使用明文，内容可能被窃听**
        + TCP/IP是可能被窃听的网络
        + 加密处理防止被窃听
        + 通信加密：SSL/TLS
        + 内容加密
    + **不验证通信方的身份，有可能遭遇伪装**
        + 任何人都可以发起请求
        + 查明对方的**证书**
    + **无法证明报文的完整性，有可能已遭篡改**
        + 接收到的内容可能有误-中间人攻击
        + 如何防止篡改--散列值校验/数字签名

- HTTPS是身披SSL外壳的HTTP

- **HTTPS采用的加密方式--防止窃听**

    对称密钥加密方式的传输效率更高，但是无法安全地将密钥 Secret Key 传输给通信方。而非对称密钥加密方式可以保证传输的安全性，因此我们可以利用非对称密钥加密方式将 Secret Key 传输给通信方。HTTPS 采用混合的加密机制，正是利用了上面提到的方案：

    - **使用非对称密钥加密方式，传输对称密钥加密方式所需要的 Secret Key，从而保证安全性**;
    - **获取到 Secret Key 后，再使用对称密钥加密方式进行通信，从而保证效率**。

- **HTTPS认证 -- 防止伪装**

    通过使用 **证书** 来对通信方进行认证。

    数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。

    服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。

    进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。

- **HTTPS完整性保护 -- 防止篡改**

    SSL 提供**报文摘要**功能来进行完整性保护。

    HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。

    HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。

- 为什么不一直使用HTTPS？
    + **加密通信会消耗更多的CPU和内存资源**，敏感信息使用HTTPS，否则使用HTTP
    + 节省证书开销

# HTTP/2.0

HTTP/1.x 实现简单是以牺牲性能为代价的：

- 客户端需要使用多个连接才能实现并发和缩短延迟；
- 不会压缩请求和响应首部，从而导致不必要的网络流量；
- 不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。

## 二进制分帧层

HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。

在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。

- 一个数据流（Stream）都有一个唯一标识符和可选的优先级信息，用于承载双向信息。
- 消息（Message）是与逻辑请求或响应对应的完整的一系列帧。
- 帧（Frame）是最小的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。

## 服务端推送

HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。

## 首部压缩

HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。

HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。

不仅如此，HTTP/2.0 也使用 **Huffman 编码**对首部字段进行压缩。