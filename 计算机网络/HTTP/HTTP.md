  \* [HTTP协议简介](#http协议简介)

  \* [HTTP报文](#http报文)

  \* [HTTP状态码](#http状态码)

  \* [Web服务器](#web服务器)

  \* [HTTP报文首部](#http报文首部)

  \* [HTTPS](#https)

# HTTP协议简介

- HTTP协议用于客户端和服务器端之间的通信；
- 通过请求和响应的交换完成通信；
- **HTTP是不保存状态的协议；为了实现保存状态的功能，引入了Cookie技术；**
- 请求URI(*统一资源标志符*)定位资源；
- 告知服务器意图的HTTP方法:
    + **GET**：获取资源，当前网络请求中，绝大部分使用的是 GET 方法。
    + **POST**：传输实体主体，POST 主要用来传输数据，而 GET 主要用来获取资源。
    + PUT：传输文件。由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。
    + **HEAD**：获取报文首部，和 GET 方法类似，但是不返回报文实体主体部分。主要用于确认 URL 的有效性以及资源更新的日期时间等。
    + DELETE：删除文件
    + **OPTIONS**：询问支持的方法
    + TRACE：追踪路径
    + **CONNECT**：要求用隧道协议连接代理
- 使用**方法**下达命令；
- **持久连接节省通信量；**
    + 只要任意一端没有明确提出断开连接，则保持TCP连接状态
    + 好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载
    + HTTP/1.1中，所有连接默认为持久连接
    + 管线化，pipelining，同时并行发送多个请求；
- **使用Cookie管理状态；**
    + 服务器端发送的响应报文中增加Set-Cookie首部字段信息，通知客户端保存Cookie
    + 下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去
    + 服务器根据请求中的Cookie信息，进行状态管理；
---

# Cookie与Session

- Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；
- Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；
- 对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。

----
# HTTP报文
- 请求报文/响应报文
- 报文首部+报文主体；由回车+换行分隔；不一定有报文主体；
- 报文首部： 请求行/状态行 + 首部字段(请求首部字段/响应首部字段 + 通用首部字段 + 实体首部字段 + 其他)
- **内容编码提升传输速率**
    + 压缩传输的内容编码：常用**gzip/compress/deflate/identify**
    + 分割发送的**分块传输编码**：传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面
- 发送多种数据的多部分对象集合：Content-type
- 获取部分内容的**范围请求**
    + 针对范围请求**Range** 首部字段，响应会返回状态码为206 Partial Content的响应报文
    + 如果服务器无法响应范围请求，会返回状态码200 OK和完整的实体内容
- **内容协商**返回最合适的内容
----
# HTTP状态码
- 状态码告知从服务器返回的请求结果； 三位数字 + 原因短语构成；
- 状态码的类别：

状态码|类别|原因短语
--|--|--
1XX|Informational(信息性状态码)|接受的请求正在梳理
2XX|Succcess(成功状态码)|请求正常处理完毕
3XX|Redirection(重定向状态码)|需要进行附加操作以完成请求
4XX|Client Error(客户端错误状态码)|服务器无法处理请求
5XX|Server Error(服务器错误状态码)|服务器处理请求出错

- 2XX 成功：
    + **200 OK**：表示从客户端发来的请求在服务器端被正常处理了
    + **204 No Content**：服务器接收的请求已成功处理，但是返回的响应报文不含实体的主体部分
    + **206 Partial Content**：客户端进行了范围请求，服务器端成功执行了请求
- 3XX 重定向：
    + **301 Moved Permanently**：永久性重定向
    + **302 Found**：临时性重定向
    + **303 See Other**：请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源
    + **304 Not Modified**：客户端发送附带条件的请求时，服务器端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回304
    + **307 Temporary Redirect**：临时重定向
- 4XX 客户端错误
    + **400 Bad Request**: 请求报文存在语法错误
    + **401 Unauthorized**: 表示请求需要通过HTTP认证，若之前已进行一次请求，则表示认证失败
    + **403 Forbidden**: 表示对请求资源的访问被服务器拒绝了
    + **404 Not Found**：表示服务器上无法找到请求的资源
- 5XX 服务器错误
    + **500 Internal Server Error**：服务器在执行请求时发生错误
    + **503 Service Unavailable**：表示服务器暂时处于超负载或正在进行停机维护，现在无法处理请求
----
# Web服务器
- 用单台**虚拟主机**实现多个域名
    + 发送HTTP请求时，必须在HOST首部内完整指定主机名和域名的URI
- 通信数据转发程序：代码、网关、隧道
    + **代理**：
        + 代理不改变请求URI
        + 代理可级联，每次通过代码服务器转发请求时，会追加写入Via首部信息
        + 通过设置组织内部的代理服务器可做到针对特定URI的访问控制
        + 利用缓存技术减少网络带宽的流量
        + 缓存代理、透明代理
    + **网关**：
        + 通过网关可以由HTTP请求转化为其他协议的通信
    + **隧道**：
        + 确保客户端与服务器进行安全通信
- 保存资源的缓存
    + 缓存是指代理服务器与客户端本地保存的资源副本
    + 利用缓存可减少对源服务器的访问，因此可节省通信流量和通信时间
    + 缓存服务器是代理服务器的一种，归类在缓存代理类型中
    + 缓存的有效期限
    + 客户端的缓存
----
# HTTP报文首部
- 通用首部字段
- 请求首部字段
- 响应首部字段
- 实体首部字段
----
# HTTPS
- HTTP的缺点：
    + **通信使用明文，内容可能被窃听**
        + TCP/IP是可能被窃听的网络
        + 加密处理防止被窃听
        + 通信加密：SSL/TLS
        + 内容加密
    + **不验证通信方的身份，有可能遭遇伪装**
        + 任何人都可以发起请求
        + 查明对方的**证书**
    + **无法证明报文的完整性，有可能已遭篡改**
        + 接收到的内容可能有误-中间人攻击
        + 如何防止篡改--散列值校验/数字签名

- HTTPS是身披SSL外壳的HTTP

- **HTTPS采用的加密方式--防止窃听**

    对称密钥加密方式的传输效率更高，但是无法安全地将密钥 Secret Key 传输给通信方。而非对称密钥加密方式可以保证传输的安全性，因此我们可以利用非对称密钥加密方式将 Secret Key 传输给通信方。HTTPS 采用混合的加密机制，正是利用了上面提到的方案：

    - **使用非对称密钥加密方式，传输对称密钥加密方式所需要的 Secret Key，从而保证安全性**;
    - **获取到 Secret Key 后，再使用对称密钥加密方式进行通信，从而保证效率**。

- **HTTPS认证 -- 防止伪装**

    通过使用 **证书** 来对通信方进行认证。

    数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。

    服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。

    进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。

- **HTTPS完整性保护 -- 防止篡改**

    SSL 提供**报文摘要**功能来进行完整性保护。

    HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。

    HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。

- 为什么不一直使用HTTPS？
    + **加密通信会消耗更多的CPU和内存资源**，敏感信息使用HTTPS，否则使用HTTP
    + 节省证书开销

# HTTP/2.0

HTTP/1.x 实现简单是以牺牲性能为代价的：

- 客户端需要使用多个连接才能实现并发和缩短延迟；
- 不会压缩请求和响应首部，从而导致不必要的网络流量；
- 不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。

## 二进制分帧层

HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。

在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。

- 一个数据流（Stream）都有一个唯一标识符和可选的优先级信息，用于承载双向信息。
- 消息（Message）是与逻辑请求或响应对应的完整的一系列帧。
- 帧（Frame）是最小的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。

## 服务端推送

HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。

## 首部压缩

HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。

HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。

不仅如此，HTTP/2.0 也使用 **Huffman 编码**对首部字段进行压缩。

---

# HTTPS工作原理

![](https://img2018.cnblogs.com/blog/1195929/201910/1195929-20191019133541927-2000837206.png)

1. 客户端使用URL访问web服务器，要求与服务器建立SSL链接（SSL之间的握手协议可以查看其他资料）。
2. 服务器收到客户端的请求后，会将网站的SSL证书信息（包含公钥）传送一份给客户端。
3. 客户端开始查找操作系统中已内置的受信任的证书发布机构CA，与服务器发来的证书进行比对。如果没找到该CA的信息，浏览器会提示不信任网站的信息。
4. 如果找到，浏览器从操作系统中取出颁发者CA的公钥将证书中的签名进行解密，对服务器进行认证，防止服务器是被冒充的。
5. 一切没问题后，浏览器与服务器进行加密等级等内容进行协商产生一个对称的密钥，然后通过接受到的证书中的公钥对这个对称密钥进行加密，传送给服务器。
6. 服务器拿到信息后用自己的私钥进行解密拿到对称密钥。于是客户端和服务器就可以通过这个对称密钥进行安全且快乐的对话了。

---

# SSL握手过程

<img src="https://www.sslchina.com/wp-content/uploads/2017/01/1-1.png" style="zoom: 50%;" />

1. 第一个消息是“**客户端问候**”，是发送给服务器的。这条消息展示出客户端具备的性能，这样服务器就可以选择怎样进行通信。
2. 服务器以“**服务器问候**”消息作回应。这条消息，告知了客户端它从列表中选择的连接参数。如果客户端和服务器不具备任何共同的性能，连接就将被终止。
3. 在“**证书**”消息中，服务器发送它的SSL证书链（包括它的叶子证书和中间证书）到客户端。与加密同样重要的是，为向连接提供验证，一个SSL证书要由一个能够使客户端验证证书合法性的CA签发。然后客户端将执行检验以确保证书合法。[3]这包括检验证书的数字签名、验证证书链以及对任何可能存在问题（如证书过期、域名错误等）的证书数据的检验。客户端也会确保服务器有证书私钥的所有权。这是在密钥交换/生成过程中完成的。
4. 这是一个可选消息，只有某些要求服务器提供额外数据的密钥交换方法才需要。
5. “**服务器问候完成**”消息告知客户端它的所有消息发送完毕。
6. 客户端也对会话密钥有帮助。这一步的细节取决于在初始“问候”消息中就已确定的密钥交换方法。TLS使用两种不同密钥：一个公钥/私钥对（SSL证书的一部分）和一个握手期间生成的会话密钥。会话密钥是“对称密钥”。它是在HTTPS连接期间使用的密钥，因为相比天然较慢的“不对称”的公钥/私钥对，它明显更快、更高效。公钥/私钥对只在会话密钥的安全传输的这几个步骤中使用。
7. “**更换密码规范**”消息使另一方知道它生成了会话密钥并要转换到加密通信。
8. 然后发送“**完成**”消息，说明握手已经完成。该消息是加密的，而且是被会话密钥保护的第一个数据。该消息包含允许双方确认握手未被篡改的数据。
9. 现在到了服务器做相同事情的时候了，服务器发送它的“**更换密码规范**”消息，表示它要转换到加密通信。
10. 服务器发送“**完成**”消息。