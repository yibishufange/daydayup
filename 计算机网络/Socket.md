# I/O模型
一个输入操作通常包括两个阶段：
- 等待数据准备好
- 从内核向进程复制数据

对于socket中的输入操作，第一步通常是等待网络中的数据到达，数据到达后会被复制到内存中的缓冲区；第二步就是数据从内核缓冲区复制到进程缓冲区。

Unix有五种I/O模型：
- 阻塞式I/O
- 非阻塞式I/O
- I/O多路复用
- 信道驱动式I/O
- 异步I/O

## 阻塞式I/O
应用进程被阻塞，直到数据从内核缓冲区复制到进程缓冲区才返回。本进程阻塞，其他进程可正常执行，不消耗CPU时间。

## 非阻塞式I/O
进程执行调用后，内核返回一个错误码。进程可以继续执行，但是需要不断的执行系统调用来获知I/O是否完成，这种方式称为轮询。
由于CPU需要处理更多的系统调用，因此CPU利用率比较低。

## I/O多路复用
使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。
它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。
如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。

## 信号驱动I/O
应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。

相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。

## 异步I/O
应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。

异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。

----
# I/O复用
select/poll/epoll 都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。

实现原理：用户将想要监视的文件描述符（File Descriptor）添加到select/poll/epoll函数中，由内核监视，函数阻塞。一旦有文件描述符就绪（读就绪或写就绪），或者超时（设置timeout），函数就会返回，然后该进程可以进行相应的读/写操作。

## select
- 将文件描述符放入一个集合中，调用select时，将这个集合从用户空间拷贝到内核空间（缺点1：每次都要复制，开销大），由内核根据就绪状态修改该集合的内容
- 集合大小有限制，32位机默认是1024（64位：2048）；
- 采用水平触发机制。
- select函数返回后，需要通过遍历这个集合，找到就绪的文件描述符（缺点3：轮询的方式效率较低），当文件描述符的数量增加时，效率会线性下降；

## poll
和select几乎没有区别，区别在于文件描述符的存储方式不同，poll采用链表的方式存储，没有最大存储数量的限制；

## epoll
- 通过内核和用户空间共享内存，避免了不断复制的问题；
- 支持的同时连接数上限很高（1G左右的内存支持10W左右的连接数）；
- 文件描述符就绪时，采用回调机制，避免了轮询（回调函数将就绪的描述符添加到一个链表中，执行epoll_wait时，返回这个链表）；
- 支持水平触发和边缘触发，采用边缘触发机制时，只有活跃的描述符才会触发回调函数。

## 选择
当连接数较多并且有很多的不活跃连接时，epoll的效率比其它两者高很多；但是当连接数较少并且都十分活跃的情况下，由于epoll需要很多回调，因此性能可能低于其它两者。