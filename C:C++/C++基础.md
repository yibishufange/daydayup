# const

作用：

1. 修饰变量，说明该**变量不可以被改变**；
2. 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；
3. 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；
4. 修饰成员函数，说明**该成员函数内不能修改成员变量**。

----

# static

作用：

1. 修饰普通变量，修改变量的**存储区域和生命周期**，使变量存储在**静态区**，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。
2. 修饰普通函数，表明函数的**作用范围**，仅在**定义该函数的文件内才能使用**。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。
3. 修饰成员变量，修饰成员变量使**所有的对象只保存一个该变量**，而且**不需要生成对象就可以访问该成员**。
4. 修饰成员函数，修饰成员函数使得**不需要生成对象就可以访问该函数**，但是在 **static 函数内不能访问非静态成员。**

---

# this指针

1. `this` 指针是一个隐含于每一个非静态成员函数中的特殊指针。**它指向调用该成员函数的那个对象。**
2. 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 `this` 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 `this` 指针。
3. 当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。
4. `this` 指针被隐含地声明为: `ClassName *const this`，这意味着不能给 `this` 指针赋值；在 `ClassName` 类的 `const` 成员函数中，`this` 指针的类型为：`const ClassName* const`，这说明不能对 `this` 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；
5. `this` 并不是一个常规变量，而是个右值，所以不能取得 `this` 的地址（不能 `&this`）。
6. 在以下场景中，经常需要显式引用`this`指针：
   1. 为实现对象的链式引用；
   2. 为避免对同一对象进行赋值操作；
   3. 在实现一些数据结构时，如 `list`。

---

# inline内联

- 特征：
  - 相当于把内联函数里面的内容写在调用内联函数处；
  - 相当于不用执行进入函数的步骤，直接执行函数体；
  - 相当于宏，却比宏多了类型检查，真正具有函数特性；
  - 编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；
  - 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数；

- 优点：
  - 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而**提高程序运行速度**。
  - 内联函数相比宏函数来说，在代码展开时，会做**安全检查或自动类型转换**（同普通函数），而宏定义则不会。
  - 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。
  - 内联函数在**运行时可调试**，而宏定义不可以。

- 缺点：
  - **代码膨胀**。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。
  - inline 函数**无法随着函数库升级而升级**。inline函数的**改变需要重新编译**，不像 non-inline 可以直接链接。
  - 是否内联，程序员不可控。内联函数只是对编译器的建议，**是否对函数内联，决定权在于编译器**。

- **虚函数可以内联，但是虚函数表现多态性的时候不能内联**。

---

# 宏定义

- 宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对 “参数” 进行的是一对一的替换。
- 宏是在预编译阶段展开，没有类型检查，不是函数；

---

# volatile

- volatile 关键字是一种**类型修饰符**，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile **告诉编译器不应对这样的对象进行优化**。
- volatile 关键字声明的变量，**每次访问时都必须从内存中取出值**（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）
- **const 可以是 volatile** （如**只读的状态寄存器**）
- **指针可以是 volatile**

---

# extern "C"

- 被 extern 限定的函数或变量是 extern 类型的
- 被 `extern "C"` 修饰的变量和函数是**按照 C 语言方式编译和链接的**
- 作用是让 C++ 编译器将 `extern "C"` 声明的代码当作 C 语言代码处理，可以**避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题**。

---

# struct/class

总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。

#### 区别

- 最本质的一个区别就是**默认的访问控制权限**
  1. 默认的**继承访问权限**。**struct 是 public 的，class 是 private** 的。
  2. struct 作为数据结构的实现体，它默认的**数据访问控制**是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。

---

# explicit关键字

- explicit 修饰**构造函数**时，可以**防止隐式转换和复制初始化**
- explicit 修饰**转换函数**时，可以**防止隐式转换**，但 [按语境转换](https://zh.cppreference.com/w/cpp/language/implicit_conversion) 除外

---

# friend友元类和友元函数

- 能访问私有成员
- 破坏封装性
- 友元关系不可传递
- 友元关系的单向性
- 友元声明的形式及数量不受限制

---

# ::范围解析运算符

#### 分类

1. **全局**作用域符（`::name`）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间
2. **类**作用域符（`class::name`）：用于表示指定类型的作用域范围是具体某个类的
3. **命名空间**作用域符（`namespace::name`）:用于表示指定类型的作用域范围是具体某个命名空间的

---

# decltype

在C++泛型编程中，经常会使用到模板，但是模板在使用时，可能会出现不知道应该声明是什么类型的状况

```c++
template<typename T1,typename t2>
void  fun(T1 a,T2 b)
{
    ?type? aplusb=a+b;
}
```

在上叙情况中，我们事先并不知道aplusb的类型，无法对其进行声明。
但是C++11中新增加的关键字decltype解决了这个问题

```cpp
int x;
decltype(x) y;
```

这使得y的类型与x相同，decltype可以是表达式，函数调用等等

```cpp
int fun1(a){return a;}
decltype (fun1) x;//令x类型与fun1的返回类型相同
------------------------------------
int x;
double y;
decltype(x+y) xpy;//令xpy类型与x+y相同
```

- 后置返回类型

  由于在提供返回类型之前，还未声明变量a,b所以无法对返回类型设置为decltype(a,b)。这时候在C++11中提供了一个解决方案，就是后置返回类型。

  ```c++
  template<typename T1,typename t2>
  auto fun(T1 a,T2 b) -> decltype(a+b)
  {
      return a+b;
  }
  ```

这个函数模板的返回类型即为decltype(a+b)。这在实际的泛型编程中非常有用，如果一开始未知要返回什么类型，先设置返回类型为auto再在后面->type(expression)，这就可以解决很大一部分的问题。

---

# 成员初始化列表

好处

- 更高效：**少了一次调用默认构造函数的过程**。
- 有些场合必须要用初始化列表：
  1. **常量成员**，因为常量只能初始化不能赋值，所以必须放在初始化列表里面
  2. **引用类型**，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面
  3. **没有默认构造函数的类**，因为使用初始化列表可以不必调用默认构造函数来初始化

---

# 面向对象

## 封装

## 继承

## 多态

- **静态多态**（编译期/早绑定）

  函数重载

  ```c++
  class A {
  public:
      void do(int a);
      void do(int a, int b);
  };
  ```

- **动态多态**（运行期/晚绑定）

  **虚函数**：用**virtual**修饰成员函数，使其成为虚函数。

  - **普通函数（非类成员函数）不能是虚函数**
  - **静态函数（static）不能是虚函数**
  - **构造函数不能是虚函数**（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）
  - **内联函数不能是表现多态性时的虚函数**

  动态多态举例：

  ```c++
  class Shape                     // 形状类
  {
  public:
      virtual double calcArea()
      {
          ...
      }
      virtual ~Shape();
  };
  class Circle : public Shape     // 圆形类
  {
  public:
      virtual double calcArea();
      ...
  };
  class Rect : public Shape       // 矩形类
  {
  public:
      virtual double calcArea();
      ...
  };
  int main()
  {
      Shape * shape1 = new Circle(4.0);
      Shape * shape2 = new Rect(5.0, 6.0);
      shape1->calcArea();         // 调用圆形类里面的方法
      shape2->calcArea();         // 调用矩形类里面的方法
      delete shape1;
      shape1 = nullptr;
      delete shape2;
      shape2 = nullptr;
      return 0;
  }
  ```

## 虚函数

- 虚析构函数

  虚析构函数是为了解决**基类的指针指向派生类对象**，并用**基类的指针删除派生类对象**。

  ```c++
  class Shape
  {
  public:
      Shape();                    // 构造函数不能是虚函数
      virtual double calcArea();
      virtual ~Shape();           // 虚析构函数
  };
  class Circle : public Shape     // 圆形类
  {
  public:
      virtual double calcArea();
      ...
  };
  int main()
  {
      Shape * shape1 = new Circle(4.0);
      shape1->calcArea();    
      delete shape1;  // 因为Shape有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏。
      shape1 = NULL;
      return 0；
  }
  ```

- 纯虚函数

  纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。

  ```c++
  virtual int A() = 0;
  ```

- 虚函数与纯虚函数区别联系
  - 类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖（override），这样的话，编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。
  - **虚函数在子类里面可以不重写**；但**纯虚函数必须在子类实现**才可以实例化子类。
  - 虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成。
  - **带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承**，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。
- 每个存在虚函数的类都有一个4字节的指针指向自己的虚函数表。

## 虚继承

虚拟继承是多重继承中特有的概念。虚拟基类是为解决多重继承而出现的。如:类D继承自类B1、B2，而类B1、B2都继承自类A，因此在类D中两次出现类A中的变量和函数。为了节省内存空间，可以将B1、B2对A的继承定义为虚拟继承，而A就成了虚拟基类。实现的代码如下：

```c++
class A;

class B1:public virtual A;

class B2:public virtual A;

class D:public B1,public B2;
```

虚拟继承在一般的应用中很少用到，所以也往往被忽视，这也主要是因为在C++中，多重继承是不推荐的，也并不常用，而一旦离开了多重继承，虚拟继承就完全失去了存在的必要因为这样只会降低效率和占用更多的空间。

- 虚继承与直接继承的区别：
  - 时间：在通过继承类对象访问虚基类对象中的成员（包括数据成员和函数成员）时，都必须通过某种间接引用来完成，这样会增加引用寻址时间（就和虚函数一样），其实就是调整this指针以指向虚基类对象，只不过这个调整是运行时完成的。
  - 空间：由于共享所以不必要在对象内存中保存多份虚基类子对象的拷贝，这样较之多继承节省空间。虚拟继承与普通继承不同的是，虚拟继承可以防止出现diamond继承时，一个派生类中同时出现了两个基类的子对象。也就是说，为了保证这一点，在虚拟继承情况下，基类子对象的布局是不同于普通继承的。因此，它需要多出一个指向基类子对象的指针。

## 重载、覆盖、隐藏的区别

- **成员函数被“重载”的特征**
  - 相同的范围（在同一个类中）；
  - 函数名字相同；
  - **参数不同**；
  - virtual 关键字可有可无。
- **“覆盖”是指派生类函数覆盖基类函数，特征是：**
  - **不同的范围**（分别位于派生类与基类）；
  - 函数名字相同；
  - 参数相同；
  - 基**类函数必须有virtual 关键字**。
- **“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，特征是：**
  - 如果派生类的函数与基类的函数**同名**，但是**参数不同**，此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。
  - 如果派生类的函数与基类的函数**同名**，但是参数相同，但是**基类函数没有virtual 关键字**。此时，基类的函数被隐藏（注意别与覆盖混淆）。